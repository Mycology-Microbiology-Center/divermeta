#' Distance-based functional diversity (q = 1) (Chiu & Chao 2014)
#'
#' Computes distance-based functional diversity \eqn{\delta D_{\sigma}}{delta D_sigma} following Chiu & Chao (2014)
#' with Shannon-type weighting (order \eqn{q = 1}{q = 1}). Pairwise distances are capped at
#' the cutoff \eqn{\sigma}{sigma}.
#'
#' @param ab Numeric vector of element abundances.
#' @param diss Numeric matrix of pairwise dissimilarities among elements.
#' @param sig Numeric cutoff \eqn{\sigma}{sigma} at which two units are considered different (default `1`).
#'
#' @return Numeric scalar, the distance-based functional diversity \eqn{\delta D_{\sigma}}{delta D_sigma}.
#' @references
#' \itemize{
#' \item Chiu CH, Chao A (2014) Distance-based functional diversity measures and their decomposition: A framework based on Hill numbers. PLOS ONE 9(7). \doi{10.1371/journal.pone.0100014}. \url{https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0100014}
#' }
#' @seealso [raoQuadratic()], [diversity.functional.traditional()]
#' @export
diversity.functional <- function(ab, diss, sig = 1) {
  diss[diss > sig] <- sig
  vals <- 1 / (1 - raoQuadratic(ab, diss) / sig)

  return(vals)
}



#' Distance-based functional diversity (order q) (Chiu & Chao 2014)
#'
#' Computes distance-based functional diversity \eqn{^{q}FD}{FD^q} following Chiu & Chao (2014).
#' This corresponds to D(Q) in their paper and \eqn{^{q}FD}{FD^q} in the divermeta manuscript.
#' For \eqn{q = 1}{q = 1}, an approximation is used internally.
#'
#' @param ab Numeric vector of element abundances.
#' @param diss Numeric matrix of pairwise dissimilarities among elements.
#' @param q Numeric order of the Hill number (non-negative).
#'
#' @return Numeric scalar, the distance-based functional diversity \eqn{^{q}FD}{FD^q}.
#' @references
#' \itemize{
#' \item Chiu CH, Chao A (2014) Distance-based functional diversity measures and their decomposition: A framework based on Hill numbers. PLOS ONE 9(7). \doi{10.1371/journal.pone.0100014}. \url{https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0100014}
#' }
#' @seealso [diversity.functional()], [raoQuadratic()]
#' @export
diversity.functional.traditional <- function(ab, diss, q = 1) {
  # Validate inputs
  if (!is.numeric(ab)) {
    stop("Abundance vector must be numeric")
  }
  if (!is.matrix(diss)) {
    stop("Dissimilarity input must be a matrix")
  }
  if (length(ab) != nrow(diss)) {
    stop("Abundance vector length must match dissimilarity matrix dimensions")
  }
  if (!is.numeric(q) || length(q) != 1) {
    stop("q parameter must be a single numeric value")
  }
  if (q < 0) {
    stop("q parameter must be positive")
  }

  if (q == 1) {
    q <- q + 10e-12
  }

  P <- as.matrix(ab / sum(ab))
  Q <- raoQuadratic(ab, diss)
  Pq <- P^q

  vals <- as.numeric(t(Pq) %*% diss %*% Pq)

  vals <- vals / Q

  vals <- vals^(1 / (1 - q))

  return(sqrt(vals))
}



#' Functional redundancy (Re) (Ricotta & Pavoine 2025)
#'
#' Computes functional redundancy \eqn{Re}{Re}, a measure of the degree to which
#' distinct elements are functionally similar given their abundances and
#' pairwise dissimilarities. This implementation follows the Simpsonâ€“Rao
#' family and corresponds to the `q = 2` case.
#'
#' @param ab Numeric vector of element abundances.
#' @param diss Numeric square matrix of pairwise dissimilarities among elements
#'   scaled to the range \[0, 1\].
#'
#' @return Numeric scalar, functional redundancy `Re`.
#' @references
#' \itemize{
#' \item Ricotta C, Pavoine S (2025) What do functional diversity, redundancy, rarity, and originality actually measure? A theoretical guide for ecologists and conservationists. Ecological Complexity 61. \doi{10.1016/j.ecocom.2025.101116}. \url{https://www.sciencedirect.com/science/article/pii/S1476945X25000017}
#' \item Rao CR (1982) Diversity and dissimilarity coefficients: A unified approach. Theoretical Population Biology 21. \doi{10.1016/0040-5809(82)90004-1}.
#' }
#' @seealso [raoQuadratic()]
#' @export
#'
redundancy <- function(ab, diss) {
  # Validate inputs
  if (!is.numeric(ab)) {
    stop("Abundance vector must be numeric")
  }
  if (!is.matrix(diss)) {
    stop("Dissimilarity input must be a matrix")
  }
  if (length(ab) != nrow(diss) || nrow(diss) != ncol(diss)) {
    stop("Abundance length must match square dissimilarity matrix dimensions")
  }
  if (any(is.na(ab)) || any(is.na(diss))) {
    stop("Input contains NA values")
  }
  if (any(ab < 0)) {
    stop("Abundances must be non-negative")
  }

  total_ab <- sum(ab)
  if (total_ab == 0) {
    stop("Total abundance cannot be zero")
  }

  p <- as.vector(ab / total_ab)

  # Simpson's diversity (q = 2): D = 1 - sum p_i^2
  D <- 1 - sum(p^2)

  # Rao's quadratic entropy
  Q <- raoQuadratic(ab, diss)

  # Functional redundancy
  res <- D - Q
  return(res)
}


#' Metagenomic Alpha-Diversity Index (MAD) (Finn 2024)
#' Computes the metagenomic alpha-diversity index, a metric that  measures the the dissimilarity of protein-encoding genes within a community.
#'
#' @param clust Vector or factor of cluster memberships for each element (gene).
#' @param diss Numeric square matrix of pairwise dissimilarities among elements (gene)
#'   scaled to the range \[0, 1\].
#' @param representatives Named list or vector mapping the cluster name to the position of the representative element of the cluster.
#'  This value is used to compute the average withn distance of the cluster. If `NULL` will choose the first element as the representative (default `NULL`).
#'
#' @return Numeric scalar, metagenomic alpha-diversity index `MAD`.
#' @references
#' \itemize{
#' \item Finn, D. R. (2024). A metagenomic alpha-diversity index for microbial functional biodiversity. FEMS Microbiology Ecology, 100(3), fiae019.
#' }
#' @seealso [multiplicity.distance()]
#' @export
#'
metagenomic.alpha.index <- function(clust, diss, representatives = NULL) {
  if (!is.matrix(diss)) {
    stop("Dissimilarity input must be a matrix")
  }
  if (length(clust) != nrow(diss) || nrow(diss) != ncol(diss)) {
    stop("Cluster memberships length must match square dissimilarity matrix dimensions")
  }
  if (any(is.na(clust)) || any(is.na(diss))) {
    stop("Input contains NA values")
  }

  # Custer names
  cluster_names <- unique(clust)

  # Validates representatives
  if (!is.null(representatives)) {
    if (!is.numeric(representatives)) {
      stop("Representative values should be numeric (indices)")
    }
    if (any(representatives < 1) || any(representatives > length(clust))) {
      stop(paste0(
        "Representative values should be between 1 and ",
        length(clust),
        "."
      ))
    }
    if (!all(cluster_names %in% names(representatives))) {
      missing <- cluster_names[!(cluster_names %in% names(representatives))]
      stop(paste0(
        "Reprentative values has missing represntative for clusters: ",
        paste(missing, collapse = ",")
      ))
    }
  }

  # Summand function
  summand <- function(cluster_name) {
    ids <- which(clust == cluster_name)
    rep <- ids[1]
    if (!is.null(representatives)) {
      rep <- representatives[[cluster_name]]
    }

    1 + mean(diss[rep, ids])
  }

  # Sum and divide
  sum(sapply(cluster_names, summand)) / length(clust)
}
